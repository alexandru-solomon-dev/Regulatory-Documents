# Базовые термины

| Term | Description |
| :--- | :--- |
| Variable | Переменная - именованная область памяти, в которой хранится значение определенного типа. Переменная имеет тип, имя и значение. |
| Parameter | Параметр - переменная, объявленная как часть метода, конструктора экземпляра, оператора или определения индексатора, которая приобретает значение при входе в этот член функции. |
| Field | Поля являются переменными, объявленными в области класса. Поле может иметь встроенный числовой тип или быть экземпляром другого класса. Например, в классе календаря может быть поле, содержащее текущую дату. |
| Constant | Константы — это поля, значения которых устанавливаются во время компиляции и не изменяются. |
| Properties | Свойства ведут себя как поля при доступе к им. Однако в отличие от полей свойства реализуются с помощью методов доступа, которые определяют инструкции, выполняемые при обращении к свойству или при его назначении. |

# Модификаторы доступа

В языке C# применяются следующие модификаторы доступа:

- `private` - закрытый или приватный компонент класса или структуры. Приватный компонент доступен только в рамках своего класса или - структуры.
- `private protected` - компонент класса доступен из любого места в своем классе или в производных классах, которые определены в той же сборке.
- `protected` - такой компонент класса доступен из любого места в своем классе или в производных классах. При этом производные классы могут располагаться в других сборках.
- `internal` - компоненты класса или структуры доступен из любого места кода в той же сборке, однако он недоступен для других программ и сборок.
- `protected internal` - совмещает функционал двух модификаторов protected и internal. Такой компонент класса доступен из любого места в текущей сборке и из производных классов, которые могут располагаться в других сборках.
- `public` - публичный, общедоступный компонент класса или структуры. Такой компонент доступен из любого места в коде, а также из других программ и сборок.

|Модификатор|Текущий класс|Производный класс из текущей сборки|Производный класс из другой сборки|Производный класс из текущей сборки|Производный класс из другой сборки|
|:-------------------|:----------------:|:----------------:|:----------------:|:----------------:|:----------------:|
|`private`           |:white_check_mark:|:x:               |:x:               |:x:               |:x:|
|`private protected` |:white_check_mark:|:white_check_mark:|:x:               |:x:               |:x:|
|`protected`         |:white_check_mark:|:white_check_mark:|:white_check_mark:|:x:               |:x:|
|`internal`          |:white_check_mark:|:white_check_mark:|:x:               |:white_check_mark:|:x:|
|`protected internal`|:white_check_mark:|:white_check_mark:|:white_check_mark:|:white_check_mark:|:x:|
|`public`            |:white_check_mark:|:white_check_mark:|:white_check_mark:|:white_check_mark:|:white_check_mark:|

# Коллекции

`Array` и `List<T>` представляют линейные, смежные контейнеры.  
В Array фиксированный объем, в то время как `List<T>` может меняться размер.  
В некоторых случаях массивы более производительны, но в целом `List<T>` более гибкий.

Класс [`Queue<T>`](https://learn.microsoft.com/ru-ru/dotnet/api/system.collections.generic.queue-1?view=net-8.0) представляет коллекцию, которая работает по алгоритму **FIFO** ("первый вошел - первый вышел").  
Класс [`Stack<T>`](https://learn.microsoft.com/ru-ru/dotnet/api/system.collections.generic.stack-1?view=net-8.0) представляет коллекцию, которая работает по алгоритму **LIFO** ("последний вошел - первый вышел"). 

> [!Note]
> Коллекции `Queue<T>` и `Stack<T>` в .NET реализованы на основе массива, а не как связанный список.  

Класс [`Dictionary<TKey, TValue>`](https://learn.microsoft.com/ru-ru/dotnet/api/system.collections.generic.dictionary-2?view=net-8.0) представляет реализацию словаря, хранит объекты, пары ключ-значение.   
Класс [`HashSet<T>`](https://learn.microsoft.com/ru-ru/dotnet/api/system.collections.generic.hashset-1?view=net-8.0) представляет классическое математическое множество. Все объекты уникальны. Если попытаться добавить уже существующий объект в коллекции, то метод `Add(T)` вернет `false` и добавления не произойдет. У каждого элемента есть свой хеш-код, позволяющий идентифицировать его в таблице. Имеется метод `UnionWith(IEnumerable<T>)` позволяющий легко добавлять элементы в множество из других коллекций.  
Класс [`LinkedList<T>`](https://learn.microsoft.com/ru-ru/dotnet/api/system.collections.generic.linkedlist-1?view=net-8.0) представляет реализацию двухсвязанного списка.

| Тип коллекции            | Размер изменяем | Наличие индексатора | Добавление элемента | Удаление элемента | Поиск элемента |
|:---|:---:|:---:|:---:|:---:|:---:|
|`Array`                   | :x:                | :white_check_mark: | :x:               | :x:  | O(n) |
|`List<T>`                 | :white_check_mark: | :white_check_mark: | O(1) / O(n)  $^1$ | O(n) | O(n) |
|`HashSet<T>`              | :white_check_mark: | :x:                | O(1) / O(n)  $^1$ | O(1) | O(1) |
|`Dictionary<TKey, TValue>`| :white_check_mark: | :white_check_mark: | O(1) / O(n)  $^1$ | O(1) | O(1) / O(n)  $^2$ |
|`Queue<T>`, `Stack<T>`    | :white_check_mark: | :x:                | O(1) / O(n)  $^1$ | O(1) | O(n) |
|`LinkedList<T>`           | :white_check_mark: | :x:                | O(1)              | O(1) | O(n) |

> 1: Первая оценка - если вместимость (capacity) позволяет и в противном случае.  
> 2: Первая оценка - по ключу, вторая - по значению.  