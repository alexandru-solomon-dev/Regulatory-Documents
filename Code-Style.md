# Рекомендации по форматированию

## Правила именования

### Код

- Используйте значимые и описательные имена для переменных, методов и классов.
- Предпочитайте ясность по поводу краткости.
- Избегайте использования аббревиаций или акронимов в именах, за исключением широко известных и принятых аббревиаций. В случаях использовании аббревиатур в имени, она считается словом и подвергается соответствующему форматированию. Например, `myJson`, `url` вместо `myJOSN` или `URL`.
- Избегайте использования однобуквенных имен, за исключением простых счетчиков циклов.
- На соглашение об именовании НЕ влияют:
   - модификаторы, такие как `static` или `readonly`.
   - любые атрибуты. В том числе влияющие на видимость в инспекторе. Такие как `[SerializeField]` или `[HideInInspector]`.
- Имена классов, методов, перечислений, пространств имен, `public`, `protected`, `internal` полей и свойств: **PascalCase**. Например, `MyClass`, `MyMethod()`.
- Имена локальных переменных, параметров: **camelCase**. Например, `localVariable`, `MyMethod(int intParameter)`.
- Имена для `private` полей и свойств: **_camelCase**. Например, `_privateField`.
- Имена интерфейсов начинаются с заглавной буквы I. Как правило имя содержит существительное и/или прилагательного с суффиксом -able.  Например `IMediator`, `IDamageable`, `IPayloadState`.
- Типы атрибутов заканчиваются словом Attribute. Например `CustomValidationAttribute`
- При объявлении эвента начинать его имя со слова 'on', если это возможно. Например `public event Action<T> OnValueChanged`, `OnTakeDamage`.
- При объявлении поля класса его имя не должно содержать существительное из имени класса. Например, для класса `PlayerMove` можно объявить поле `MoveSpeed`, но не `PlayerSpeed`. Или для `Heath` - `CurrentValue`, а не `CurrentHeath`.

> [!Note]
> При необходимости в имя поля или параметра включите единицы измерения или обязательно распишите [`summary`](#Summary), если это может вызвать путаницу или недопонимание.
> Например для поля `_rotationSpeed`: 
> ```C#
> /// <summary>
> /// Rotational speed in radians per second.
> /// </summary>
> private float _rotationSpeed;
> ```
> Иначе переименовать в `_rotationSpeedRadianPerSecond`.

### Файлы

- Имена файлов и каталогов приводятся в **PascalCase**, например `MyFile.cs`.
- По возможности имя файла должно совпадать с именем основного класса в файле, например, `MyClass.cs`.
- В целом, предпочтительно использовать один основной класс в одном файле.

## Организация

Декларации использования пространств имен идут сверху, перед любыми пространствами имен. Порядок использования импорта - алфавитный, за исключением импорта System, который всегда идет первым.

<details>
<summary>Example</summary>

```C#
using System;
using System.Collections;
using CodeBase.MyNamespace;
using UnityEngine;
using Zenject;

namespace Namespace1
{  ...  }

namespace Namespace2
{  ...
  namespace NestedNamespace
  {  ...  }
}
```
</details>

Упорядочивание членов класса:
Группируйте члены класса в следующем порядке:
- Вложенные классы, перечисления, делегаты и события.
- Статические, const и readonly поля.
- Поля и свойства.
- Конструкторы и финализаторы.
- Методы.

Внутри каждой группы элементы должны располагаться в следующем порядке:  
1. `public`  
1. `internal`  
1. `protected internal`  
1. `protected`  
1. `private`

По возможности группируйте реализации интерфейсов вместе. 

[Пример структуры класса](https://github.com/Krasnov-Midnight/Regulatory-Documents/blob/main/Example/ClassOrganization.cs)

> [!Note]
> - MonoBehaviour эвент методы, такие как `OnTriggerEnter`, `OnEnable` и т.п. Ставятся по иерархии выше.  
> - Исключением нарушения порядка расположения элементов в зависимости от уровня доступа является только для достижения расположения сериализивынных полей в логические группы. Что бы не использовать группировку от сторонних инструментов или Editor скрипты.
> - Если есть публичные вложенные классы или перечисления, рассмотрите вариант сделать их внешними.

## Правила отступов

- Не более одного объявления в строке. Например, `int variableA, variableB;` :x:
- Не более одного присвоения в строке. Например, `variableA = variableB = 127;` :x:
- Отступ - 2 пробела, без табуляции.
- Ограничение символов в строке 125. При необходимости может выставляться по самой малой вместимости символов на экране среди разработчиков. 
- Пробел после `if`/`for`/`while` и т. д., а также после запятых.
- После открывающей скобки и перед закрывающей скобкой пробел не ставится.
- Нет пробела между унарным оператором и его операндом. Один пробел между оператором и каждым операндом всех остальных операторов.
- Открывающая скобка и закрывающая скобка на новой строке.
- Пустые блоки могут быть краткими. Например, `void DoNothing() {}`
- Допускается объявление коротких `enum` и коллекций в одну строку. Например, `int[] a = new[] { 1, 2, 3 };`
- Скобки используются, даже если они необязательны. Исключением может быть только для конструкции `if` c `continue`, `return` или `break`.  
Например, `if (!condition) return;`
- В общем случае продолжения строк отступают на 4 пробела.
- Разрывы строк со скобками (например, инициализаторы списков, лямбды, инициализаторы объектов и т. д.) не считаются продолжением.
- Для определений и вызовов функций, если все аргументы не помещаются в одну строку, их следует разбить на несколько строк, при этом каждая последующая строка должна быть выровнена по первому аргументу. Если места для этого недостаточно, аргументы могут быть размещены в последующих строках с отступом в четыре пробела.

[Пример с правилами отступов](https://github.com/Krasnov-Midnight/Regulatory-Documents/blob/main/Example/WhiteSpacesRules.cs)

# Рекомендации по кодированию

## Модификаторы доступа

Предпочитайте наиболее ограничивающий [модификатор доступа](Terms-and-explanations#модификаторы-доступа).  
Модификатор доступа указывается всегда, даже когда это необязательно.

## Константы

- Переменные и поля, которые можно сделать `const`, всегда должны быть `const`.
- Если `const` невозможна, подходящей альтернативой может быть `readonly`.
- Предпочитайте именованные константы магическим числам.

## Коллекции

### Выбор коллекции

В зависимости от задачи старайтесь подобрать наиболее подходящую коллекцию.

- В общем случае для публичных переменных, свойств и возвращаемых типов предпочитайте `List<T>`.
- Предпочитайте `List<T>`, если размер контейнера может меняться.
- Предпочтите массивы, если размер контейнера фиксирован и известен на момент конструирования.
- Если необходимо часто добавлять и удалять элементы 
  - и порядок элементов важен - рассмотрите связанные списки `LinkedList<T>` или `Stack<T>`, `Queue<T>`.
  - и при этом нужен индексатор, то рассмотрите `Dictionary<TKey, TValue>`.  
Словари занимают больше оперативной памяти, чем `List<T>`, однако более быстрое удаление элементов.
  - и необходима проверка на наличие какого-либо элемента в коллекции - `HashSet<T>`.
- При использовании `List<T>`, `HashSet<T>`, `Dictionary<TKey, TValue>`, `Stack<T>`, `Queue<T>`, по возможности, укажите ожидаемое количество элементов.  
Например `HashSet<Collider> _obstacles = new (10);`

[Краткая сводка о типах коллекций](Terms-and-explanations#коллекции)

### Передача коллекций

- В качестве публичного поля или свойства отдайте предпочтение наиболее ограничивающему варианту. Например, `IReadOnlyList`.
- В качестве параметров метода используйте наиболее ограничивающий тип коллекции, например `IReadOnlyCollection` / `IReadOnlyList` / `IEnumerable`, когда коллекция должна быть неизменяемой.
- Для результата метода, если вы передаете право собственности на возвращаемую коллекцию, предпочтите IList, или полный тип коллекции, а не IEnumerable. Если право собственности не передается, отдайте предпочтение наиболее ограничивающему варианту.

## Expression body

### Свойства

- Для свойств, доступных только для чтения, по возможности предпочитайте expression body (=>) выражения.  
Например, `private bool isEmpty => _list == null || _list.Count == 0;`
- Для всего остального используйте синтаксис { get; set; }. Например, `public int Count => { get; private set; }`

### Методы

По возможности предпочитайте expression body (=>). В случае если все выражение не влезает в строку, переносится тело метода.
Например, 
```C#
public float Foo() => DoSomething(_value);

private float DoSomething(float value) => 
  (MethodWithVeryLongName(value) + MethodWithVeryLongName2(value)) / MethodWithVeryLongName3(value);
```

## Структуры и классы

Структуры всегда передаются и возвращаются по значению, а классы по ссылке.
Присвоение значения члену возвращаемой структуры не изменяет оригинал - например, если выставить `Vector3 newPosition = transform.position; newPosition.x = 10;`, то объект не окажется в позиции по X равной 10. Так как position здесь является структурой Vector3, которая передается по значению.

Почти всегда используйте `class`.
Используйте `struct`, когда с типом можно обращаться как с другими типами значений - например, если экземпляры типа малы и обычно недолговечны или часто встраиваются в другие объекты. Хорошими примерами являются `Vector3`, `Quaternion` и `Bounds`.

## Строки

- В общем, используйте то, что легче всего читается, и лучше всего подходит под задачу.  
- Имейте в виду, что цепочные конкатенации (`operator+`) будут медленнее и вызовут значительный перерасход памяти.  
- Для сцепления коротких строк рекомендуется использовать интерполяцию строк.  
Например, при помощи строкового литерала `$`:  
`string message = $"Hello, {name}! {DateTime.Now:M} is such a beautiful day today!";`  
Или при помощи `string.Format`:  
```C#
string messageFormat = "Hello, {0}! {1:M} is such a beautiful day today!";
string message = string.Format(messageFormat, name, DateTime.Now);
```  
- Для добавления строк в циклах, особенно при работе со строками больших размеров, для производительности используйте StringBuilder.  
Например:
```C#
public string PrisonerReport(IReadOnlyCollection<Prisoner> prisonerList)
{
  string prisonerFormatting = "\nPrisoner {0};\tID: {1};\tLaw article: {2};\tRelease Date:{3:d}";
  var reportText = new StringBuilder();
  reportText.Append($"Of prisoners in custody {prisonerList.Count}: ");
  foreach (Prisoner prisoner in prisonerList)
  {
    reportText.Append(string.Format(prisonerFormatting, prisoner.Name, prisoner.Id, prisoner.LawArticle, prisoner.ReleaseDate));
  }

  return reportText.ToString();
}
``` 
## Делегаты и лямбды

Приветствуется использование системных делегатов [`Func<> и Action<>`](https://learn.microsoft.com/ru-ru/dotnet/standard/delegates-lambdas), не обязательно определять свои типы делегатов.  
Если [лямбда](https://learn.microsoft.com/ru-ru/dotnet/csharp/language-reference/operators/lambda-expressions) нетривиальна (например, состоит более чем из пары операторов) или используется повторно в нескольких местах, она, вероятно, должна быть именованным методом.  

## Использование `ref` и `out`

- Используйте `out` для возврата, которые также являются входами.
- Поместите параметры `out` после всех остальных параметров в определении метода.
- Старайтесь избегать использования `ref`, он необходим только когда нужно мутировать входные данные.
- Не используйте `ref` для передачи изменяемого контейнера в метод. `ref` требуется только в том случае, если предоставленный контейнер должен быть заменен на совершенно другой экземпляр контейнера.
- Использование `ref` как оптимизация для передачи структур, только в крайней необходимости.

## Использование ключевого слова `var`

Использование `var` приветствуется, если оно способствует удобочитаемости, позволяя избежать очевидных или несущественных имен типов.

- Например при объявлении переменой в случае когда в правой части тип явно указывается.  
Например, `var ticket = new Ticket();`, `var intArray = new int[4];`, `var request = Factory.Create<HttpRequest>();`.
- Для переходных переменных, которые исключительно передаются в другие методы.  
Например, `var item = GetItem(); ProcessItem(item);`

> [!Note]
> При объявлении коллекции, рекомендуется использовать короткую форму записи, вместо `var`, если это возможно.  
> Например, `Stack<int> intStack = new ();`, `List<int> intList = new (10);`.  
> Краткая форма записи невозможно при создании Array, и при инициализации коллекции со значениями.  
> Например, `var intArray = new int[3];` или `var listInt = new List<int> { 1, 2, 5, 1, 63, 7 };`

Запрещается использовать `var` в следующих случаях:
- В цикле `foreach` всегда указывайте тип явно. Например, `foreach(People testSubject in _controlGroup)`.
- При работе с базовыми типами. Например, `bool success = true;`, `string message = "message text";`, `int counter = 0;`.
- При получении результата из метода, когда тип явно не указывается. Не полагайтесь на то, что имя метода предоставляет информацию о типе. Например, `Item item = GetItem();`

## Использование кортежей 

- В целом, предпочтите передачу класса, а не `Tuple<T1, .., Tn>`, особенно при возврате сложных типов.
- Если было принято решение использовать `Tuple`, используете именованный кортеж.  
Например, `public (float min, float max, int count) GetInfo()`.

## Атрибуты

Атрибуты должны располагаться в строке над полем, свойством, классом или методом, с которым они связаны, и отделяться от члена новой строкой.  
Исключением может быть при расположении не более одного атрибута в строке объявления свойства или поля, если это благоприятно повлияет на читаемость кода.  
Несколько атрибутов должны быть каждый в своих скобках и разделены новыми строками. Это позволяет легче добавлять и удалять атрибуты, а также обеспечивает удобный поиск.

[Пример использования атрибутов](https://github.com/Krasnov-Midnight/Regulatory-Documents/blob/main/Example/AttributeExample.cs)

## Summary
