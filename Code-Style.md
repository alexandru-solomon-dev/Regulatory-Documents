# Рекомендации по форматированию

## Правила именования

### Код

- Используйте значимые и описательные имена для переменных, методов и классов.
- Предпочитайте ясность по поводу краткости.
- Избегайте использования аббревиаций или акронимов в именах, за исключением широко известных и принятых аббревиаций. В случаях использовании аббревиатур в имени, она считается словом и подвергается соответствующему форматированию. Например, `myJson`, `url` вместо `myJOSN` или `URL`.
- Избегайте использования однобуквенных имен, за исключением простых счетчиков циклов.
- На соглашение об именовании НЕ влияют:
   - модификаторы, такие как `static` или `readonly`.
   - любые атрибуты. В том числе влияющие на видимость в инспекторе. Такие как `[SerializeField]` или `[HideInInspector]`.
- Имена классов, методов, перечислений, пространств имен, а так же `public`, `protected`, `internal` полей и свойств: **PascalCase**. Например, `MyClass`, `MyMethod()`.
- Имена локальных переменных, параметров: **camelCase**. Например, `localVariable`, `MyMethod(int intParameter)`.
- Имена для `private` полей и свойств: **_camelCase**. Например, `_privateField`.
- Имена интерфейсов начинаются с заглавной буквы I. Как правило имя содержит существительное и/или прилагательного с суффиксом -able.  Например `IMediator`, `IDamageable`, `IPayloadState`.
- Типы атрибутов заканчиваются словом Attribute. Например `CustomValidationAttribute`
- При объявлении эвента начинать его имя со слова 'on', если это возможно. Например `public event Action<T> OnValueChanged`, `OnTakeDamage`.
- При объявлении поля класса его имя не должно содержать существительное из имени класса. Например, для класса `PlayerMove` можно объявить поле `MoveSpeed`, но не `PlayerSpeed`. Или для `Heath` - `CurrentValue`, а не `CurrentHeath`.

> [!Tip]
> Если единицы измерения могут вызвать путаницу или недопонимание, в имя поля или параметра включите единицы измерения или предпочтительнее будет расписать [`документирующий комментарий`](#документирующие).  
> Например для поля `_rotationSpeed`: 
> ```C#
> /// <value>
> /// Rotational speed in radians per second.
> /// </value>
> private float _rotationSpeed;
> ```
> Иначе - `_rotationSpeedRadianPerSecond`.

### Файлы

- Имена файлов и каталогов приводятся в **PascalCase**, например `MyFile.cs`.
- По возможности имя файла должно совпадать с именем основного класса в файле, например, `MyClass.cs`.
- В целом, предпочтительно использовать один основной класс в одном файле.

## Организация

Декларации использования пространств имен идут сверху, перед любыми пространствами имен. Порядок использования импорта - алфавитный, за исключением импорта System, который всегда идет первым.

<details>
<summary>Example</summary>

```C#
using System;
using System.Collections;
using CodeBase.MyNamespace;
using UnityEngine;
using Zenject;

namespace Namespace1
{  ...  }

namespace Namespace2
{  ...
  namespace NestedNamespace
  {  ...  }
}
```
</details>

Упорядочивание членов класса:
Группируйте члены класса в следующем порядке:
- Вложенные классы, перечисления, делегаты и события.
- Статические, const и readonly поля.
- Поля и свойства.
- Конструкторы и финализаторы.
- Методы.

Внутри каждой группы элементы должны располагаться в следующем порядке:  
1. `public`  
1. `internal`  
1. `protected internal`  
1. `protected`  
1. `private`

По возможности группируйте реализации интерфейсов вместе. 

[Пример структуры класса](https://github.com/Krasnov-Midnight/Regulatory-Documents/blob/main/Example/ClassOrganization.cs)

> [!Note]
> - MonoBehaviour эвент методы, такие как `OnTriggerEnter`, `OnEnable` и т.п. Ставятся по иерархии выше.  
> - Исключением нарушения порядка расположения элементов в зависимости от уровня доступа является только для достижения расположения сериализивынных полей в логические группы. Что бы не использовать группировку от сторонних инструментов или Editor скрипты.
> - Если есть публичные вложенные классы или перечисления, рассмотрите вариант сделать их внешними.

## Правила отступов

- Не более одного объявления в строке. Например, `int variableA, variableB;` :x:
- Не более одного присвоения в строке. Например, `variableA = variableB = 127;` :x:
- Отступ - 2 пробела, без табуляции.
- Ограничение символов в строке 125. При необходимости может выставляться по самой малой вместимости символов на экране среди разработчиков. 
- Пробел после `if`/`for`/`while` и т. д., а также после запятых.
- После открывающей скобки и перед закрывающей скобкой пробел не ставится.
- Нет пробела между унарным оператором и его операндом. Один пробел между оператором и каждым операндом всех остальных операторов.
- Используйте стиль Allman для фигурных скобок: открытый и закрывающий фигурные скобки своей собственной новой линии. Фигурные скобки соответствуют текущему уровню отступа.
- Пустые блоки могут быть краткими. Например, `void DoNothing() {}`
- Допускается объявление коротких `enum` и коллекций в одну строку. Например, `int[] a = new[] { 1, 2, 3 };`
- Скобки используются, даже если они необязательны. Исключением может быть только для конструкции `if` c `continue`, `return` или `break`.  
Например, `if (!condition) return;`
- В общем случае продолжения строк отступают на 4 пробела.
- Разрывы строк со скобками (например, инициализаторы списков, лямбды, инициализаторы объектов и т. д.) не считаются продолжением.
- Для определений и вызовов функций, если все аргументы не помещаются в одну строку, их следует разбить на несколько строк, при этом каждая последующая строка должна быть выровнена по первому аргументу. Если места для этого недостаточно, аргументы могут быть размещены в последующих строках с отступом в четыре пробела.

[Пример с правилами отступов](https://github.com/Krasnov-Midnight/Regulatory-Documents/blob/main/Example/WhiteSpacesRules.cs)

# Рекомендации по кодированию

## Модификаторы доступа

Предпочитайте наиболее ограничивающий [модификатор доступа](Terms-and-explanations#модификаторы-доступа).  
Модификатор доступа указывается всегда, даже когда это необязательно.

## Константы

- Переменные и поля, которые можно сделать `const`, всегда должны быть `const`.
- Если `const` невозможна, подходящей альтернативой может быть `readonly`.
- Предпочитайте именованные константы магическим числам.

## Коллекции

### Выбор коллекции

В зависимости от задачи старайтесь подобрать наиболее подходящую коллекцию.

- В общем случае для публичных переменных, свойств и возвращаемых типов предпочитайте `List<T>`.
- Предпочитайте `List<T>`, если размер контейнера может меняться.
- Предпочтите массивы, если размер контейнера фиксирован и известен на момент конструирования.
- Если необходимо часто добавлять и удалять элементы 
  - и порядок элементов важен - рассмотрите связанные списки `LinkedList<T>` или `Stack<T>`, `Queue<T>`.
  - и при этом нужен индексатор, то рассмотрите `Dictionary<TKey, TValue>`.  
Словари занимают больше оперативной памяти, чем `List<T>`, однако более быстрое удаление элементов.
  - и необходима проверка на наличие какого-либо элемента в коллекции - `HashSet<T>`.
- При использовании `List<T>`, `HashSet<T>`, `Dictionary<TKey, TValue>`, `Stack<T>`, `Queue<T>`, по возможности, укажите ожидаемое количество элементов.  
Например `HashSet<Collider> _obstacles = new (10);`

[Краткая сводка о типах коллекций](Terms-and-explanations#коллекции)

### Передача коллекций

- В качестве публичного поля или свойства отдайте предпочтение наиболее ограничивающему варианту. Например, `IReadOnlyList`.
- В качестве параметров метода используйте наиболее ограничивающий тип коллекции, например `IReadOnlyCollection` / `IReadOnlyList` / `IEnumerable`, когда коллекция должна быть неизменяемой.
- Для результата метода, если вы передаете право собственности на возвращаемую коллекцию, предпочтите IList, или полный тип коллекции, а не IEnumerable. Если право собственности не передается, отдайте предпочтение наиболее ограничивающему варианту.

## Expression body

### Свойства

- Для свойств, доступных только для чтения, по возможности предпочитайте expression body (=>) выражения.  
Например, `private bool isEmpty => _list == null || _list.Count == 0;`
- Для всего остального используйте синтаксис { get; set; }. Например, `public int Count => { get; private set; }`

### Методы

По возможности предпочитайте expression body (=>). В случае если все выражение не влезает в строку, переносится тело метода.
Например, 
```C#
public float Foo() => DoSomething(_value);

private float DoSomething(float value) => 
  (MethodWithVeryLongName(value) + MethodWithVeryLongName2(value)) / MethodWithVeryLongName3(value);
```

## Структуры и классы

Структуры всегда передаются и возвращаются по значению, а классы по ссылке.
Присвоение значения члену возвращаемой структуры не изменяет оригинал - например, если выставить `Vector3 newPosition = transform.position; newPosition.x = 10;`, то объект не окажется в позиции по X равной 10. Так как position здесь является структурой Vector3, которая передается по значению.

Почти всегда используйте `class`.
Используйте `struct`, когда с типом можно обращаться как с другими типами значений - например, если экземпляры типа малы и обычно недолговечны или часто встраиваются в другие объекты. Хорошими примерами являются `Vector3`, `Quaternion` и `Bounds`.

## Строки

- В общем, используйте то, что легче всего читается, и лучше всего подходит под задачу.  
- Имейте в виду, что цепочные конкатенации (`operator+`) будут медленнее и вызовут значительный перерасход памяти.  
- Для сцепления коротких строк рекомендуется использовать интерполяцию строк.  
Например, при помощи строкового литерала `$`:  
`string message = $"Hello, {name}! {DateTime.Now:M} is such a beautiful day today!";`  
Или при помощи `string.Format`:  
```C#
string messageFormat = "Hello, {0}! {1:M} is such a beautiful day today!";
string message = string.Format(messageFormat, name, DateTime.Now);
```  
- Для добавления строк в циклах, особенно при работе со строками больших размеров, для производительности используйте StringBuilder.  
Например:
```C#
public string PrisonerReport(IReadOnlyCollection<Prisoner> prisonerList)
{
  string prisonerFormatting = "\nPrisoner {0};\tID: {1};\tLaw article: {2};\tRelease Date:{3:d}";
  var reportText = new StringBuilder();
  reportText.Append($"Of prisoners in custody {prisonerList.Count}: ");
  foreach (Prisoner prisoner in prisonerList)
  {
    reportText.Append(string.Format(prisonerFormatting, prisoner.Name, prisoner.Id, prisoner.LawArticle, prisoner.ReleaseDate));
  }

  return reportText.ToString();
}
``` 
## Делегаты и лямбды

Приветствуется использование системных делегатов [`Func<> и Action<>`](https://learn.microsoft.com/ru-ru/dotnet/standard/delegates-lambdas), не обязательно определять свои типы делегатов.  
Если [лямбда](https://learn.microsoft.com/ru-ru/dotnet/csharp/language-reference/operators/lambda-expressions) нетривиальна (например, состоит более чем из пары операторов) или используется повторно в нескольких местах, она, вероятно, должна быть именованным методом.  

> [!Note]
> Лямбды используют замыкание, избегайте ловушек замыкания.
> Замыкание – это специальный тип функции, с помощью которого она ссылается на свободные переменные. Это позволяет замкнутым функциям использовать переменные вне своей области видимости.  
> Пример ловушки замыкания:  
> 
> <details>
> <summary>Example</summary>
> 
> ```C#  
> List<Action> actionList = new (3);  
> 
> for (int i = 0; i < 3; i++)  
>   actionList.Add(() => print(i));  
> 
> foreach (Action action in actionList)   
>   action.Invoke();  
> ```  
> 
> Output:  
> ```
> 3  
> 3  
> 3  
> ```  
> </details>

## Использование `ref` и `out`

- Используйте `out` для возврата, которые также являются входами.
- Поместите параметры `out` после всех остальных параметров в определении метода.
- Старайтесь избегать использования `ref`, он необходим только когда нужно мутировать входные данные.
- Не используйте `ref` для передачи изменяемого контейнера в метод. `ref` требуется только в том случае, если предоставленный контейнер должен быть заменен на совершенно другой экземпляр контейнера.
- Использование `ref` как оптимизация для передачи структур, только в крайней необходимости.

## Использование ключевого слова `var`

Использование `var` приветствуется, если оно способствует удобочитаемости, позволяя избежать очевидных или несущественных имен типов.

- Например при объявлении переменой в случае когда в правой части тип явно указывается.  
Например, `var ticket = new Ticket();`, `var intArray = new int[4];`, `var request = Factory.Create<HttpRequest>();`.
- Для переходных переменных, которые исключительно передаются в другие методы.  
Например, `var item = GetItem(); ProcessItem(item);`

> [!Note]
> При объявлении коллекции, рекомендуется использовать короткую форму записи, вместо `var`, если это возможно.  
> Например, `Stack<int> intStack = new ();`, `List<int> intList = new (10);`.  
> Краткая форма записи невозможно при создании Array, и при инициализации коллекции со значениями.  
> Например, `var intArray = new int[3];` или `var listInt = new List<int> { 1, 2, 5, 1, 63, 7 };`

Запрещается использовать `var` в следующих случаях:
- В цикле `foreach` всегда указывайте тип явно. Например, `foreach(People testSubject in _controlGroup)`.
- При работе с базовыми типами. Например, `bool success = true;`, `string message = "message text";`, `int counter = 0;`.
- При получении результата из метода, когда тип явно не указывается. Не полагайтесь на то, что имя метода предоставляет информацию о типе. Например, `Item item = GetItem();`

## Использование кортежей 

- В целом, предпочтите передачу класса, а не `Tuple<T1, .., Tn>`, особенно при возврате сложных типов.
- Если было принято решение использовать `Tuple`, используете именованный кортеж.  
Например, `public (float min, float max, int count) GetInfo()`.

## Атрибуты

Атрибуты должны располагаться в строке над полем, свойством, классом или методом, с которым они связаны, и отделяться от члена новой строкой.  
Исключением может быть при расположении не более одного атрибута в строке объявления свойства или поля, если это благоприятно повлияет на читаемость кода.  
Несколько атрибутов должны быть каждый в своих скобках и разделены новыми строками. Это позволяет легче добавлять и удалять атрибуты, а также обеспечивает удобный поиск.

[Пример использования атрибутов](https://github.com/Krasnov-Midnight/Regulatory-Documents/blob/main/Example/AttributeExample.cs)

## Комментарии

Форматирование:

- В тексте комментария используйте только латинские буквы, цифры, знаки препинания и символы математических операций.
- Комментарий размещается на отдельной строке, а не в конце или внутри строки кода.
- Текст комментария начинается с заглавной буквы.
- Текст комментария завершается точкой `.` или восклицательным знаком `!`.
- Вставьте один пробел между разделителем комментариев и текстом комментария. Например, (`// Text.`) или (`/* Text. */`).

### Поясняющие

> *По-настоящему хороший комментарий — тот, без которого вам удалось обойтись.*

В общем случае, старайтесь избегать необходимости в комментариях. Выделение именованных метов, и корректно именованные члены помогут сделать код более читаемым и понятным.

Комментарии могут быть полезны в следующих случаях:

- Документирующие комментарии, [`summary`](#документирующие).
- Комментарии, содержащие юридическую информацию.  
При необходимости указания информации о копирайте, лицензии и т.п.
- Предупреждающие комментарии.  
Иногда появляются какие-то важные моменты, на которые обязательно нужно обратить внимание или предупредить о чем-либо.
- TODO комментарии.   
Современные IDE умеют находить все TODO-комментарии и выдавать их списком, таким образом это можно использовать как маркер, указывающий на код который нужно доработать.
- Комментарии алгоритмов и формул.  
В случаях, когда приходится использовать сложные алгоритмические решения или какие-либо математические формулы, например определенного физического явления, стоит указать название и по возможности ссылку на источник. Предпочтительнее такого рода комментарии оформлять в качестве [`документирующих`](#документирующие).

Избегайте больших комментариев, но если необходимо - используйте (`/* */`) для длинных объяснений.  
Для комментариев в 1-2 строки используйте одностроковый комментарий (`//`).

### Документирующие

Для описания работы методов, области ответственности классов, пояснения для полей, свойств класса и всех общедоступных элементов используются [документирующие XML-комментарии](https://learn.microsoft.com/ru-ru/dotnet/csharp/language-reference/xmldoc/).  
Это [специальные XML-теги](https://learn.microsoft.com/en-us/dotnet/visual-basic/language-reference/xmldoc/?redirectedfrom=MSDN), которые содержаться в комментариях и позволяют автоматически сгенерировать XML-файл.  
Так же IntelliSense будет автоматически отображать информацию о задокументированых членах. Что может сильно облегчить работу и сэкономит время вам и другим разработчикам.

Такие комментарии в обязательном порядке составлять для:  
- классов и структур.
- `public`, `protected` и `internal` методов и эвентов.
- для свойств имеющих `set` с модификатором доступа `public`, `protected` и `internal`, которая вызывает какую-либо логику.

> [!Tip]
> Документирующие XML-комментарии не обязательны для свойств, полей и `private` методов. Однако для некоторых из них рекомендуется составить `summary`, например в случаях если необходимо уточнить работу метода, или указать на что может влиять свойство, или прояснить единицы измерения.

В большинстве сред разработки, что бы добавить такой комментарий, нужно ввести 3 слеша (`///`) над членом, который хотим задокументировать. После чего автоматически сгенерируется простой шаблон. Если это делается для метода, будет учтена его сигнатура и добавлены соответствующие секции.

Рассмотрим основные XML-теги: 

| Тег | Применение |
| :--- | :--- |
| `<c>` | Применяет форматирование как для исходного кода. Можно написать одну строку, можно объявлять внутри других тегов. |
| `<code>` | Много строк исходного кода, можно объявлять внутри других тегов. |
| `<example>` | Пример использования описываемого члена. |
| `<exception>` | Позволяет указать, какие исключения метод может выдавать. |
| `<param>` | Описания параметров, каждый параметр описывается отдельно. |
| `<remarks>` | Секция с дополнительной информация, помимо тега `<summary>`. |
| `<returns>` | Описание возвращаемого параметра. |
| `<see>` | Позволяет указывать ссылки на член или поле, доступное для вызова из текущей среды компиляции. |
| `<seealso>` | Текст в секции «Смотри также». Удобно указывать ссылки на внешние ресурсы в данном разделе. |
| `<summary>` | Секция с общим описанием. |
| `<typeparam>` | Описание дженерик параметров. |
| `<value>` | Для описания свойств и полей. Обратите внимание, что когда вы добавляете комментарий к свойствам и полям, автоматически будет создан тег `<summary>`, тег `<value>` нужно будет добавить вручную.  |

Предпочитайте указывать теги в таком порядке:  
1. `<summary>`
1. `<param>` / `<value>` (для свойств и полей)
1. `<typeparam>`
1. `<returns>`
1. `<exception>`
1. `<remarks>`
1. `<example>`
1. `<seealso>`

[Примеры использования XML-комментариев](https://github.com/Krasnov-Midnight/Regulatory-Documents/blob/main/Example/XmlCommentaries.cs)

Для xml есть 5 зарезервированных символа, что бы их отобразить необходимо использовать специальные символьные ссылки:
| Символ | Сущность |
| --- | --- |
| < | `&lt;` |
| > | `&gt;` |
| & | `&amp;` |
| ' | `&apos;` |
| " | `&quot;` |